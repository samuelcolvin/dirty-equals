{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p> Doing dirty (but extremely useful) things with equals. </p> <p> </p> <p>Documentation for development version: 2b7c8fa</p> <p>dirty-equals is a python library that (mis)uses the <code>__eq__</code> method to make python code (generally unit tests) more declarative and therefore easier to read and write.</p> <p>dirty-equals can be used in whatever context you like, but it comes into its own when writing unit tests for applications where you're commonly checking the response to API calls and the contents of a database.</p>"},{"location":"#usage","title":"Usage","text":"<p>Here's a trivial example of what dirty-equals can do:</p> Trivial Usage<pre><code>from dirty_equals import IsPositive\nassert 1 == IsPositive  # (1)!\nassert -2 == IsPositive  # this will fail! (2)\n</code></pre> <ol> <li>This <code>assert</code> will pass since <code>1</code> is indeed positive, so the result of <code>1 == IsPositive</code> is <code>True</code>.</li> <li>This will fail (raise a <code>AssertionError</code>) since <code>-2</code> is not positive,    so the result of <code>-2 == IsPositive</code> is <code>False</code>.</li> </ol> <p>Not that interesting yet!, but consider the following unit test code using dirty-equals:</p> More Powerful Usage<pre><code>from dirty_equals import IsJson, IsNow, IsPositiveInt, IsStr\ndef test_user_endpoint(client: 'HttpClient', db_conn: 'Database'):\nclient.post('/users/create/', data=...)\nuser_data = db_conn.fetchrow('select * from users')\nassert user_data == {\n'id': IsPositiveInt,  # (1)!\n'username': 'samuelcolvin',  # (2)!\n'avatar_file': IsStr(regex=r'/[a-z0-9\\-]{10}/example\\.png'),  # (3)!\n'settings_json': IsJson({'theme': 'dark', 'language': 'en'}),  # (4)!\n'created_ts': IsNow(delta=3),  # (5)!\n}\n</code></pre> <ol> <li>We don't actually care what the <code>id</code> is, just that it's present, it's an <code>int</code> and it's positive.</li> <li>We can use a normal key and value here since we know exactly what value <code>username</code> should have before we test it.</li> <li><code>avatar_file</code> is a string, but we don't know all of the string before the <code>assert</code>,    just the format (regex) it should match.</li> <li><code>settings_json</code> is a <code>JSON</code> string, but it's simpler and more robust to confirm it represents a particular python    object rather than compare strings.</li> <li><code>created_at</code> is a <code>datetime</code>, although we don't know (or care) about its exact value;    since the user was just created we know it must be close to now. <code>delta</code> is optional, it defaults to 2 seconds.</li> </ol> <p>Without dirty-equals, you'd have to compare individual fields and/or modify some fields before comparison - the test would not be declarative or as clear.</p> <p>dirty-equals can do so much more than that, for example:</p> <ul> <li><code>IsPartialDict</code> lets you compare a subset of a dictionary</li> <li><code>IsStrictDict</code> lets you confirm order in a dictionary</li> <li><code>IsList</code> and <code>IsTuple</code> lets you compare partial lists and tuples,   with or without order constraints</li> <li>nesting any of these types inside any others</li> <li><code>IsInstance</code> lets you simply confirm the type of an object</li> <li>You can even use boolean operators <code>|</code> and <code>&amp;</code> to combine multiple conditions</li> <li>and much more...</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Simply:</p> <pre><code>pip install dirty-equals\n</code></pre> <p>dirty-equals requires Python 3.8+.</p>"},{"location":"internals/","title":"Internals","text":""},{"location":"internals/#how-the-magic-of-dirtyequals__eq__-works","title":"How the magic of <code>DirtyEquals.__eq__</code> works?","text":"<p>When you call <code>x == y</code>, Python first calls <code>x.__eq__(y)</code>. This would not help us much, because we would have to keep an eye on order of the arguments when comparing to <code>DirtyEquals</code> objects. But that's where were another feature of Python comes in.</p> <p>When <code>x.__eq__(y)</code> returns the <code>NotImplemented</code> object, then Python will try to call <code>y.__eq__(x)</code>. Objects in the standard library return that value when they don't know how to compare themselves to objects of <code>type(y)</code> (Without checking the C source I can't be certain if this assumption holds for all classes, but it works for all the basic ones). In <code>pathlib.PurePath</code> you can see an example how that is implemented in Python.</p> <p>By default, object implements <code>__eq__()</code> by using <code>is</code>, returning <code>NotImplemented</code> in the case of a false comparison: <code>True if x is y else NotImplemented</code>.</p> <p>See the Python documentation for more information (<code>object.__eq__</code>).</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#boolean-logic","title":"Boolean Logic","text":"<p>dirty-equals types can be combined based on either <code>&amp;</code> (and, all checks must be <code>True</code> for the combined check to be <code>True</code>) or <code>|</code> (or, any check can be <code>True</code> for the combined check to be <code>True</code>).</p> <p>Types can also be inverted using the <code>~</code> operator, this is equivalent to using <code>!=</code> instead of <code>==</code>.</p> <p>Example: Boolean Combination of Types<pre><code>from dirty_equals import Contains, HasLen\nassert ['a', 'b', 'c'] == HasLen(3) &amp; Contains('a')  # (1)!\nassert ['a', 'b', 'c'] == HasLen(3) | Contains('z')  # (2)!\nassert ['a', 'b', 'c'] != Contains('z')\nassert ['a', 'b', 'c'] == ~Contains('z')\n</code></pre></p> <ol> <li>The object on the left has to both have length 3 and contain <code>\"a\"</code></li> <li>The object on the left has to either have length 3 or contain <code>\"z\"</code></li> </ol>"},{"location":"usage/#initialised-vs-class-comparison","title":"Initialised vs. Class comparison","text":"<p>Warning</p> <p>This does not work with PyPy.</p> <p>dirty-equals allows comparison with types regardless of whether they've been initialised.</p> <p>This saves users adding <code>()</code> in lots of places.</p> <p>Example:</p> Initialised vs. Uninitialised<pre><code>from dirty_equals import IsInt\n# these two cases are the same\nassert 1 == IsInt\nassert 1 == IsInt()\n</code></pre> <p>Note</p> <p>Types that require at least on argument when being initialised (like <code>IsApprox</code>) cannot be used like this, comparisons will just return <code>False</code>.</p>"},{"location":"usage/#__repr__-and-pytest-compatibility","title":"<code>__repr__</code> and pytest compatibility","text":"<p>dirty-equals types have reasonable <code>__repr__</code> methods, which describe types and generally are a close match of how they would be created:</p> __repr__<pre><code>from dirty_equals import IsApprox, IsInt\nassert repr(IsInt) == 'IsInt'\nassert repr(IsInt()) == 'IsInt()'\nassert repr(IsApprox(42)) == 'IsApprox(approx=42)'\n</code></pre> <p>However, the repr method of types changes when an equals (<code>==</code>) operation on them returns a <code>True</code>, in this case the <code>__repr__</code> method will return <code>repr(other)</code>.</p> repr() after comparison<pre><code>from dirty_equals import IsInt\nv = IsInt()\nassert 42 == v\nassert repr(v) == '42'\n</code></pre> <p>This black magic is designed to make the output of pytest when asserts on large objects fail as simple as possible to read.</p> <p>Consider the following unit test:</p> pytest error example<pre><code>from datetime import datetime\nfrom dirty_equals import IsNow, IsPositiveInt\ndef test_partial_dict():\napi_response_data = {\n'id': 1,  # (1)!\n'first_name': 'John',\n'last_name': 'Doe',\n'created_at': datetime.now().isoformat(),\n'phone': '+44 123456789',\n}\nassert api_response_data == {\n'id': IsPositiveInt(),\n'first_name': 'John',\n'last_name': 'Doe',\n'created_at': IsNow(iso_string=True),\n# phone number is missing, so the test will fail\n}\n</code></pre> <ol> <li>For simplicity we've hardcoded <code>id</code> here, but in a test it could be any positive int,    hence why we need <code>IsPositiveInt()</code></li> </ol> <p>Here's an except from the output of <code>pytest -vv</code> show the error details:</p> pytest output<pre><code>E         Common items:\nE         {'created_at': '2022-02-25T15:41:38.493512',\nE          'first_name': 'John',\nE          'id': 1,\nE          'last_name': 'Doe'}\nE         Left contains 1 more item:\nE         {'phone': '+44 123456789'}\nE         Full diff:\nE           {\nE            'created_at': '2022-02-25T15:41:38.493512',\nE            'first_name': 'John',\nE            'id': 1,\nE            'last_name': 'Doe',\nE         +  'phone': '+44 123456789',\nE           }\n</code></pre> <p>It's easy to see that the <code>phone</code> key is missing, <code>id</code> and <code>created_at</code> are represented by the exact values they were compared to, so don't show as different in the \"Full diff\" section.</p> <p>Warning</p> <p>This black magic only works when using initialised types, if <code>IsPositiveInt</code> was used instead <code>IsPositiveInt()</code> in the above example, the output would not be as clean.</p>"},{"location":"types/boolean/","title":"Boolean Types","text":""},{"location":"types/boolean/#dirty_equals.IsTrueLike","title":"IsTrueLike","text":"<pre><code>IsTrueLike(*repr_args: Any, **repr_kwargs: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[bool]</code></p> <p>Check if the value is True like. <code>IsTrueLike</code> allows comparison to anything and effectively uses just <code>return bool(other)</code>.</p> <p>Example of basic usage:</p> IsTrueLike<pre><code>from dirty_equals import IsTrueLike\nassert True == IsTrueLike\nassert 1 == IsTrueLike\nassert 'true' == IsTrueLike\nassert 'foobar' == IsTrueLike  # any non-empty string is \"True\"\nassert '' != IsTrueLike\nassert [1] == IsTrueLike\nassert {} != IsTrueLike\nassert None != IsTrueLike\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*repr_args</code> <code>Any</code> <p>unnamed args to be used in <code>__repr__</code></p> <code>()</code> <code>**repr_kwargs</code> <code>Any</code> <p>named args to be used in <code>__repr__</code></p> <code>{}</code>"},{"location":"types/boolean/#dirty_equals.IsFalseLike","title":"IsFalseLike","text":"<pre><code>IsFalseLike(*, allow_strings: bool = False)\n</code></pre> <p>             Bases: <code>DirtyEquals[bool]</code></p> <p>Check if the value is False like. <code>IsFalseLike</code> allows comparison to anything and effectively uses <code>return not bool(other)</code> (with string checks if <code>allow_strings=True</code> is set).</p> <p>Parameters:</p> Name Type Description Default <code>allow_strings</code> <code>bool</code> <p>if <code>True</code>, allow comparisons to <code>False</code> like strings, case-insensitive, allows <code>''</code>, <code>'false'</code> and any string where <code>float(other) == 0</code> (e.g. <code>'0'</code>).</p> <code>False</code> <p>Example of basic usage:</p> IsFalseLike<pre><code>from dirty_equals import IsFalseLike\nassert False == IsFalseLike\nassert 0 == IsFalseLike\nassert 'false' == IsFalseLike(allow_strings=True)\nassert '0' == IsFalseLike(allow_strings=True)\nassert 'foobar' != IsFalseLike(allow_strings=True)\nassert 'false' != IsFalseLike\nassert 'True' != IsFalseLike(allow_strings=True)\nassert [1] != IsFalseLike\nassert {} == IsFalseLike\nassert None == IsFalseLike\nassert '' == IsFalseLike(allow_strings=True)\nassert '' == IsFalseLike\n</code></pre>"},{"location":"types/custom/","title":"Custom Types","text":""},{"location":"types/custom/#dirty_equals._base.DirtyEquals","title":"DirtyEquals","text":"<p>             Bases: <code>Generic[T]</code></p> <p>Base type for all dirty-equals types.</p>"},{"location":"types/custom/#dirty_equals._base.DirtyEquals.value","title":"value  <code>property</code>","text":"<pre><code>value: T\n</code></pre> <p>Property to get the value last successfully compared to this object.</p> <p>This is seldom very useful, put it's provided for completeness.</p> <p>Example of usage:</p> .values<pre><code>from dirty_equals import IsStr\ntoken_is_str = IsStr(regex=r't-.+')\nassert 't-123' == token_is_str\nprint(token_is_str.value)\n#&gt; t-123\n</code></pre>"},{"location":"types/custom/#dirty_equals._base.DirtyEquals.__init__","title":"__init__","text":"<pre><code>__init__(*repr_args: Any, **repr_kwargs: Any)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*repr_args</code> <code>Any</code> <p>unnamed args to be used in <code>__repr__</code></p> <code>()</code> <code>**repr_kwargs</code> <code>Any</code> <p>named args to be used in <code>__repr__</code></p> <code>{}</code>"},{"location":"types/custom/#dirty_equals._base.DirtyEquals.equals","title":"equals","text":"<pre><code>equals(other: Any) -&gt; bool\n</code></pre> <p>Abstract method, must be implemented by subclasses.</p> <p><code>TypeError</code> and <code>ValueError</code> are caught in <code>__eq__</code> and indicate <code>other</code> is not equals to this type.</p>"},{"location":"types/custom/#custom-type-example","title":"Custom Type Example","text":"<p>To demonstrate the use of custom types, we'll create a custom type that matches any even number.</p> <p>We won't inherit from <code>IsNumeric</code> in this case to keep the example simple.</p> IsEven<pre><code>from decimal import Decimal\nfrom typing import Any, Union\nfrom dirty_equals import DirtyEquals, IsOneOf\nclass IsEven(DirtyEquals[Union[int, float, Decimal]]):\ndef equals(self, other: Any) -&gt; bool:\nreturn other % 2 == 0\nassert 2 == IsEven\nassert 3 != IsEven\nassert 'foobar' != IsEven\nassert 3 == IsEven | IsOneOf(3)\n</code></pre> <p>There are a few advantages of inheriting from <code>DirtyEquals</code> compared to just implementing your own class with an <code>__eq__</code> method:</p> <ol> <li><code>TypeError</code> and <code>ValueError</code> in <code>equals</code> are caught and result in a not-equals result.</li> <li>A useful <code>__repr__</code> is generated, and modified if the <code>==</code> operation returns <code>True</code>,    see pytest compatibility</li> <li>boolean logic works out of the box</li> <li>Uninitialised usage    (<code>IsEven</code> rather than <code>IsEven()</code>) works out of the box</li> </ol>"},{"location":"types/datetime/","title":"Date and Time Types","text":""},{"location":"types/datetime/#dirty_equals.IsDatetime","title":"IsDatetime","text":"<pre><code>IsDatetime(*, approx: datetime | None = None, delta: timedelta | int | float | None = None, gt: datetime | None = None, lt: datetime | None = None, ge: datetime | None = None, le: datetime | None = None, unix_number: bool = False, iso_string: bool = False, format_string: str | None = None, enforce_tz: bool = True)\n</code></pre> <p>             Bases: <code>IsNumeric[datetime]</code></p> <p>Check if the value is a datetime, and matches the given conditions.</p> <p>Parameters:</p> Name Type Description Default <code>approx</code> <code>datetime | None</code> <p>A value to approximately compare to.</p> <code>None</code> <code>delta</code> <code>timedelta | int | float | None</code> <p>The allowable different when comparing to the value to <code>approx</code>, if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to <code>timedelta</code>s.</p> <code>None</code> <code>gt</code> <code>datetime | None</code> <p>Value which the compared value should be greater than (after).</p> <code>None</code> <code>lt</code> <code>datetime | None</code> <p>Value which the compared value should be less than (before).</p> <code>None</code> <code>ge</code> <code>datetime | None</code> <p>Value which the compared value should be greater than (after) or equal to.</p> <code>None</code> <code>le</code> <code>datetime | None</code> <p>Value which the compared value should be less than (before) or equal to.</p> <code>None</code> <code>unix_number</code> <code>bool</code> <p>whether to allow unix timestamp numbers in comparison</p> <code>False</code> <code>iso_string</code> <code>bool</code> <p>whether to allow iso formatted strings in comparison</p> <code>False</code> <code>format_string</code> <code>str | None</code> <p>if provided, <code>format_string</code> is used with <code>datetime.strptime</code> to parse strings</p> <code>None</code> <code>enforce_tz</code> <code>bool</code> <p>whether timezone should be enforced in comparison, see below for more details</p> <code>True</code> <p>Examples of basic usage:</p> IsDatetime<pre><code>from datetime import datetime\nfrom dirty_equals import IsDatetime\ny2k = datetime(2000, 1, 1)\nassert datetime(2000, 1, 1) == IsDatetime(approx=y2k)\n# Note: this requires the system timezone to be UTC\nassert 946684800.123 == IsDatetime(approx=y2k, unix_number=True)\nassert datetime(2000, 1, 1, 0, 0, 9) == IsDatetime(approx=y2k, delta=10)\nassert '2000-01-01T00:00' == IsDatetime(approx=y2k, iso_string=True)\nassert datetime(2000, 1, 2) == IsDatetime(gt=y2k)\nassert datetime(1999, 1, 2) != IsDatetime(gt=y2k)\n</code></pre>"},{"location":"types/datetime/#timezones","title":"Timezones","text":"<p>Timezones are hard, anyone who claims otherwise is either a genius, a liar, or an idiot.</p> <p><code>IsDatetime</code> and its subtypes (e.g. <code>IsNow</code>) can be used in two modes, based on the <code>enforce_tz</code> parameter:</p> <ul> <li><code>enforce_tz=True</code> (the default):<ul> <li>if the datetime wrapped by <code>IsDatetime</code> is timezone naive, the compared value must also be timezone naive.</li> <li>if the datetime wrapped by <code>IsDatetime</code> has a timezone, the compared value must have a   timezone with the same offset.</li> </ul> </li> <li><code>enforce_tz=False</code>:<ul> <li>if the datetime wrapped by <code>IsDatetime</code> is timezone naive, the compared value can either be naive or have a   timezone all that matters is the datetime values match.</li> <li>if the datetime wrapped by <code>IsDatetime</code> has a timezone, the compared value needs to represent the same point in   time - either way it must have a timezone.</li> </ul> </li> </ul> <p>Example</p> IsDatetime &amp; timezones<pre><code>from datetime import datetime\nfrom zoneinfo import ZoneInfo\nfrom dirty_equals import IsDatetime\ntz_london = ZoneInfo('Europe/London')\nnew_year_london = datetime(2000, 1, 1, tzinfo=tz_london)\ntz_nyc = ZoneInfo('America/New_York')\nnew_year_eve_nyc = datetime(1999, 12, 31, 19, 0, 0, tzinfo=tz_nyc)\nassert new_year_eve_nyc == IsDatetime(approx=new_year_london, enforce_tz=False)\nassert new_year_eve_nyc != IsDatetime(approx=new_year_london, enforce_tz=True)\nnew_year_naive = datetime(2000, 1, 1)\nassert new_year_naive != IsDatetime(approx=new_year_london, enforce_tz=False)\nassert new_year_naive != IsDatetime(approx=new_year_eve_nyc, enforce_tz=False)\nassert new_year_london == IsDatetime(approx=new_year_naive, enforce_tz=False)\nassert new_year_eve_nyc != IsDatetime(approx=new_year_naive, enforce_tz=False)\n</code></pre>"},{"location":"types/datetime/#dirty_equals.IsNow","title":"IsNow","text":"<pre><code>IsNow(*, delta: timedelta | int | float = 2, unix_number: bool = False, iso_string: bool = False, format_string: str | None = None, enforce_tz: bool = True, tz: str | tzinfo | None = None)\n</code></pre> <p>             Bases: <code>IsDatetime</code></p> <p>Check if a datetime is close to now, this is similar to <code>IsDatetime(approx=datetime.now())</code>, but slightly more powerful.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>timedelta | int | float</code> <p>The allowable different when comparing to the value to now, if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to <code>timedelta</code>s.</p> <code>2</code> <code>unix_number</code> <code>bool</code> <p>whether to allow unix timestamp numbers in comparison</p> <code>False</code> <code>iso_string</code> <code>bool</code> <p>whether to allow iso formatted strings in comparison</p> <code>False</code> <code>format_string</code> <code>str | None</code> <p>if provided, <code>format_string</code> is used with <code>datetime.strptime</code> to parse strings</p> <code>None</code> <code>enforce_tz</code> <code>bool</code> <p>whether timezone should be enforced in comparison, see below for more details</p> <code>True</code> <code>tz</code> <code>str | tzinfo | None</code> <p>either a <code>ZoneInfo</code>, a <code>datetime.timezone</code> or a string which will be passed to <code>ZoneInfo</code>, (or <code>pytz.timezone</code> on 3.8) to get a timezone, if provided now will be converted to this timezone.</p> <code>None</code> IsNow<pre><code>from datetime import datetime, timezone\nfrom dirty_equals import IsNow\nnow = datetime.now()\nassert now == IsNow\nassert now.timestamp() == IsNow(unix_number=True)\nassert now.timestamp() != IsNow\nassert now.isoformat() == IsNow(iso_string=True)\nassert now.isoformat() != IsNow\nutc_now = datetime.utcnow().replace(tzinfo=timezone.utc)\nassert utc_now == IsNow(tz=timezone.utc)\n</code></pre>"},{"location":"types/datetime/#dirty_equals.IsDate","title":"IsDate","text":"<pre><code>IsDate(*, approx: date | None = None, delta: timedelta | int | float | None = None, gt: date | None = None, lt: date | None = None, ge: date | None = None, le: date | None = None, iso_string: bool = False, format_string: str | None = None)\n</code></pre> <p>             Bases: <code>IsNumeric[date]</code></p> <p>Check if the value is a date, and matches the given conditions.</p> <p>Parameters:</p> Name Type Description Default <code>approx</code> <code>date | None</code> <p>A value to approximately compare to.</p> <code>None</code> <code>delta</code> <code>timedelta | int | float | None</code> <p>The allowable different when comparing to the value to now, if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to <code>timedelta</code>s.</p> <code>None</code> <code>gt</code> <code>date | None</code> <p>Value which the compared value should be greater than (after).</p> <code>None</code> <code>lt</code> <code>date | None</code> <p>Value which the compared value should be less than (before).</p> <code>None</code> <code>ge</code> <code>date | None</code> <p>Value which the compared value should be greater than (after) or equal to.</p> <code>None</code> <code>le</code> <code>date | None</code> <p>Value which the compared value should be less than (before) or equal to.</p> <code>None</code> <code>iso_string</code> <code>bool</code> <p>whether to allow iso formatted strings in comparison</p> <code>False</code> <code>format_string</code> <code>str | None</code> <p>if provided, <code>format_string</code> is used with <code>datetime.strptime</code> to parse strings</p> <code>None</code> <p>Examples of basic usage:</p> IsDate<pre><code>from datetime import date\nfrom dirty_equals import IsDate\ny2k = date(2000, 1, 1)\nassert date(2000, 1, 1) == IsDate(approx=y2k)\nassert '2000-01-01' == IsDate(approx=y2k, iso_string=True)\nassert date(2000, 1, 2) == IsDate(gt=y2k)\nassert date(1999, 1, 2) != IsDate(gt=y2k)\n</code></pre>"},{"location":"types/datetime/#dirty_equals.IsToday","title":"IsToday","text":"<pre><code>IsToday(*, iso_string: bool = False, format_string: str | None = None)\n</code></pre> <p>             Bases: <code>IsDate</code></p> <p>Check if a date is today, this is similar to <code>IsDate(approx=date.today())</code>, but slightly more powerful.</p> <p>Parameters:</p> Name Type Description Default <code>iso_string</code> <code>bool</code> <p>whether to allow iso formatted strings in comparison</p> <code>False</code> <code>format_string</code> <code>str | None</code> <p>if provided, <code>format_string</code> is used with <code>datetime.strptime</code> to parse strings</p> <code>None</code> IsToday<pre><code>from datetime import date, timedelta\nfrom dirty_equals import IsToday\ntoday = date.today()\nassert today == IsToday\nassert today.isoformat() == IsToday(iso_string=True)\nassert today.isoformat() != IsToday\nassert today + timedelta(days=1) != IsToday\nassert today.strftime('%Y/%m/%d') == IsToday(format_string='%Y/%m/%d')\nassert today.strftime('%Y/%m/%d') != IsToday()\n</code></pre>"},{"location":"types/dict/","title":"Dictionary Types","text":""},{"location":"types/dict/#dirty_equals.IsDict","title":"IsDict","text":"<pre><code>IsDict(*expected_args: dict[Any, Any], **expected_kwargs: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[Dict[Any, Any]]</code></p> <p>Base class for comparing dictionaries. By default, <code>IsDict</code> isn't particularly useful on its own (it behaves pretty much like a normal <code>dict</code>), but it can be subclassed (see <code>IsPartialDict</code> and <code>IsStrictDict</code>) or modified with <code>.settings(...)</code> to powerful things.</p> <p>Can be created from either keyword arguments or an existing dictionary (same as <code>dict()</code>).</p> <p><code>IsDict</code> is not particularly useful on its own, but it can be subclassed or modified with <code>.settings(...)</code> to facilitate powerful comparison of dictionaries.</p> IsDict<pre><code>from dirty_equals import IsDict\nassert {'a': 1, 'b': 2} == IsDict(a=1, b=2)\nassert {1: 2, 3: 4} == IsDict({1: 2, 3: 4})\n</code></pre>"},{"location":"types/dict/#dirty_equals.IsDict.settings","title":"settings","text":"<pre><code>settings(*, strict: bool | None = None, partial: bool | None = None, ignore: None | Container[Any] | Callable[[Any], bool] = NotGiven) -&gt; IsDict\n</code></pre> <p>Allows you to customise the behaviour of <code>IsDict</code>, technically a new <code>IsDict</code> is required to allow chaining.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If <code>True</code>, the order of key/value pairs must match.</p> <code>None</code> <code>partial</code> <code>bool</code> <p>If <code>True</code>, only keys include in the wrapped dict are checked.</p> <code>None</code> <code>ignore</code> <code>Union[None, Container[Any], Callable[[Any], bool]]</code> <p>Values to omit from comparison. Can be either a <code>Container</code> (e.g. <code>set</code> or <code>list</code>) of values to ignore, or a function that takes a value and should return <code>True</code> if the value should be ignored.</p> <code>NotGiven</code> IsDict.settings(...)<pre><code>from dirty_equals import IsDict\nassert {'a': 1, 'b': 2, 'c': None} != IsDict(a=1, b=2)\nassert {'a': 1, 'b': 2, 'c': None} == IsDict(a=1, b=2).settings(partial=True)  # (1)!\nassert {'b': 2, 'a': 1} == IsDict(a=1, b=2)\nassert {'b': 2, 'a': 1} != IsDict(a=1, b=2).settings(strict=True)  # (2)!\n# combining partial and strict\nassert {'a': 1, 'b': None, 'c': 3} == IsDict(a=1, c=3).settings(\nstrict=True, partial=True\n)\nassert {'b': None, 'c': 3, 'a': 1} != IsDict(a=1, c=3).settings(\nstrict=True, partial=True\n)\n</code></pre> <ol> <li>This is the same as <code>IsPartialDict(a=1, b=2)</code></li> <li>This is the same as <code>IsStrictDict(a=1, b=2)</code></li> </ol>"},{"location":"types/dict/#dirty_equals.IsPartialDict","title":"IsPartialDict","text":"<pre><code>IsPartialDict(*expected_args: dict[Any, Any], **expected_kwargs: Any)\n</code></pre> <p>             Bases: <code>IsDict</code></p> <p>Partial dictionary comparison, this is the same as <code>IsDict(...).settings(partial=True)</code>.</p> IsPartialDict<pre><code>from dirty_equals import IsPartialDict\nassert {'a': 1, 'b': 2, 'c': 3} == IsPartialDict(a=1, b=2)\nassert {'a': 1, 'b': 2, 'c': 3} != IsPartialDict(a=1, b=3)\nassert {'a': 1, 'b': 2, 'd': 3} != IsPartialDict(a=1, b=2, c=3)\n# combining partial and strict\nassert {'a': 1, 'b': None, 'c': 3} == IsPartialDict(a=1, c=3).settings(strict=True)\nassert {'b': None, 'c': 3, 'a': 1} != IsPartialDict(a=1, c=3).settings(strict=True)\n</code></pre> <p>Can be created from either keyword arguments or an existing dictionary (same as <code>dict()</code>).</p> <p><code>IsDict</code> is not particularly useful on its own, but it can be subclassed or modified with <code>.settings(...)</code> to facilitate powerful comparison of dictionaries.</p> IsDict<pre><code>from dirty_equals import IsDict\nassert {'a': 1, 'b': 2} == IsDict(a=1, b=2)\nassert {1: 2, 3: 4} == IsDict({1: 2, 3: 4})\n</code></pre>"},{"location":"types/dict/#dirty_equals.IsIgnoreDict","title":"IsIgnoreDict","text":"<pre><code>IsIgnoreDict(*expected_args: dict[Any, Any], **expected_kwargs: Any)\n</code></pre> <p>             Bases: <code>IsDict</code></p> <p>Dictionary comparison with <code>None</code> values ignored, this is the same as <code>IsDict(...).settings(ignore={None})</code>.</p> <p><code>.settings(...)</code> can be used to customise the behaviour of <code>IsIgnoreDict</code>, in particular changing which values are ignored.</p> IsIgnoreDict<pre><code>from dirty_equals import IsIgnoreDict\nassert {'a': 1, 'b': 2, 'c': None} == IsIgnoreDict(a=1, b=2)\nassert {'a': 1, 'b': 2, 'c': 'ignore'} == (\nIsIgnoreDict(a=1, b=2).settings(ignore={None, 'ignore'})\n)\ndef is_even(v: int) -&gt; bool:\nreturn v % 2 == 0\nassert {'a': 1, 'b': 2, 'c': 3, 'd': 4} == (\nIsIgnoreDict(a=1, c=3).settings(ignore=is_even)\n)\n# combining partial and strict\nassert {'a': 1, 'b': None, 'c': 3} == IsIgnoreDict(a=1, c=3).settings(strict=True)\nassert {'b': None, 'c': 3, 'a': 1} != IsIgnoreDict(a=1, c=3).settings(strict=True)\n</code></pre> <p>Can be created from either keyword arguments or an existing dictionary (same as <code>dict()</code>).</p> <p><code>IsDict</code> is not particularly useful on its own, but it can be subclassed or modified with <code>.settings(...)</code> to facilitate powerful comparison of dictionaries.</p> IsDict<pre><code>from dirty_equals import IsDict\nassert {'a': 1, 'b': 2} == IsDict(a=1, b=2)\nassert {1: 2, 3: 4} == IsDict({1: 2, 3: 4})\n</code></pre>"},{"location":"types/dict/#dirty_equals.IsStrictDict","title":"IsStrictDict","text":"<pre><code>IsStrictDict(*expected_args: dict[Any, Any], **expected_kwargs: Any)\n</code></pre> <p>             Bases: <code>IsDict</code></p> <p>Dictionary comparison with order enforced, this is the same as <code>IsDict(...).settings(strict=True)</code>.</p> IsDict.settings(...)<pre><code>from dirty_equals import IsStrictDict\nassert {'a': 1, 'b': 2} == IsStrictDict(a=1, b=2)\nassert {'a': 1, 'b': 2, 'c': 3} != IsStrictDict(a=1, b=2)\nassert {'b': 2, 'a': 1} != IsStrictDict(a=1, b=2)\n# combining partial and strict\nassert {'a': 1, 'b': None, 'c': 3} == IsStrictDict(a=1, c=3).settings(partial=True)\nassert {'b': None, 'c': 3, 'a': 1} != IsStrictDict(a=1, c=3).settings(partial=True)\n</code></pre> <p>Can be created from either keyword arguments or an existing dictionary (same as <code>dict()</code>).</p> <p><code>IsDict</code> is not particularly useful on its own, but it can be subclassed or modified with <code>.settings(...)</code> to facilitate powerful comparison of dictionaries.</p> IsDict<pre><code>from dirty_equals import IsDict\nassert {'a': 1, 'b': 2} == IsDict(a=1, b=2)\nassert {1: 2, 3: 4} == IsDict({1: 2, 3: 4})\n</code></pre>"},{"location":"types/inspection/","title":"Type Inspection","text":""},{"location":"types/inspection/#dirty_equals.IsInstance","title":"IsInstance","text":"<pre><code>IsInstance(expected_type: ExpectedType, *, only_direct_instance: bool = False)\n</code></pre> <p>             Bases: <code>DirtyEquals[ExpectedType]</code></p> <p>A type which checks that the value is an instance of the expected type.</p> <p>Parameters:</p> Name Type Description Default <code>expected_type</code> <code>ExpectedType</code> <p>The type to check against.</p> required <code>only_direct_instance</code> <code>bool</code> <p>whether instances of subclasses of <code>expected_type</code> should be considered equal.</p> <code>False</code> <p>Note</p> <p><code>IsInstance</code> can be parameterized or initialised with a type - <code>IsInstance[Foo]</code> is exactly equivalent to <code>IsInstance(Foo)</code>.</p> <p>This allows usage to be analogous to type hints.</p> <p>Example: IsInstance<pre><code>from dirty_equals import IsInstance\nclass Foo:\npass\nclass Bar(Foo):\npass\nassert Foo() == IsInstance[Foo]\nassert Foo() == IsInstance(Foo)\nassert Foo != IsInstance[Bar]\nassert Bar() == IsInstance[Foo]\nassert Foo() == IsInstance(Foo, only_direct_instance=True)\nassert Bar() != IsInstance(Foo, only_direct_instance=True)\n</code></pre></p>"},{"location":"types/inspection/#dirty_equals.HasName","title":"HasName","text":"<pre><code>HasName(expected_name: Union[IsStr, str], *, allow_instances: bool = True)\n</code></pre> <p>             Bases: <code>DirtyEquals[T]</code></p> <p>A type which checks that the value has the given <code>__name__</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>expected_name</code> <code>Union[IsStr, str]</code> <p>The name to check against.</p> required <code>allow_instances</code> <code>bool</code> <p>whether instances of classes with the given name should be considered equal, (e.g. whether <code>other.__class__.__name__ == expected_name</code> should be checked).</p> <code>True</code> <p>Example: HasName<pre><code>from dirty_equals import HasName, IsStr\nclass Foo:\npass\nassert Foo == HasName('Foo')\nassert Foo == HasName['Foo']\nassert Foo() == HasName('Foo')\nassert Foo() != HasName('Foo', allow_instances=False)\nassert Foo == HasName(IsStr(regex='F..'))\nassert Foo != HasName('Bar')\nassert int == HasName('int')\nassert int == HasName('int')\n</code></pre></p>"},{"location":"types/inspection/#dirty_equals.HasRepr","title":"HasRepr","text":"<pre><code>HasRepr(expected_repr: Union[IsStr, str])\n</code></pre> <p>             Bases: <code>DirtyEquals[T]</code></p> <p>A type which checks that the value has the given <code>repr()</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>expected_repr</code> <code>Union[IsStr, str]</code> <p>The expected repr value.</p> required <p>Example: HasRepr<pre><code>from dirty_equals import HasRepr, IsStr\nclass Foo:\ndef __repr__(self):\nreturn 'This is a Foo'\nassert Foo() == HasRepr('This is a Foo')\nassert Foo() == HasRepr['This is a Foo']\nassert Foo == HasRepr(IsStr(regex='&lt;class.+'))\nassert 42 == HasRepr('42')\nassert 43 != HasRepr('42')\n</code></pre></p>"},{"location":"types/inspection/#dirty_equals.HasAttributes","title":"HasAttributes","text":"<pre><code>HasAttributes(*expected_args: Dict[Any, Any], **expected_kwargs: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[Any]</code></p> <p>A type which checks that the value has the given attributes.</p> <p>This is a partial check - e.g. the attributes provided to check do not need to be exhaustive.</p> <p>Can be created from either keyword arguments or an existing dictionary (same as <code>dict()</code>).</p> <p>Example: HasAttributes<pre><code>from dirty_equals import AnyThing, HasAttributes, IsInt, IsStr\nclass Foo:\ndef __init__(self, a, b):\nself.a = a\nself.b = b\ndef spam(self):\npass\nassert Foo(1, 2) == HasAttributes(a=1, b=2)\nassert Foo(1, 2) == HasAttributes(a=1)\nassert Foo(1, 's') == HasAttributes(a=IsInt, b=IsStr)\nassert Foo(1, 2) != HasAttributes(a=IsInt, b=IsStr)\nassert Foo(1, 2) != HasAttributes(a=1, b=2, c=3)\nassert Foo(1, 2) == HasAttributes(a=1, b=2, spam=AnyThing)\n</code></pre></p>"},{"location":"types/numeric/","title":"Numeric Types","text":""},{"location":"types/numeric/#dirty_equals.IsInt","title":"<code>IsInt</code>","text":"<p>             Bases: <code>IsNumeric[int]</code></p> <p>Checks that a value is an integer.</p> <p>Inherits from <code>IsNumeric</code> and can therefore be initialised with any of its arguments.</p> IsInt<pre><code>from dirty_equals import IsInt\nassert 1 == IsInt\nassert -2 == IsInt\nassert 1.0 != IsInt\nassert 'foobar' != IsInt\nassert True != IsInt\nassert 1 == IsInt(exactly=1)\nassert -2 != IsInt(exactly=1)\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsInt.allowed_types","title":"<code>allowed_types = int</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>As the name suggests, only integers are allowed, booleans (<code>True</code> are <code>False</code>) are explicitly excluded although technically they are sub-types of <code>int</code>.</p>"},{"location":"types/numeric/#dirty_equals.IsFloat","title":"<code>IsFloat</code>","text":"<p>             Bases: <code>IsNumeric[float]</code></p> <p>Checks that a value is a float.</p> <p>Inherits from <code>IsNumeric</code> and can therefore be initialised with any of its arguments.</p> IsFloat<pre><code>from dirty_equals import IsFloat\nassert 1.0 == IsFloat\nassert 1 != IsFloat\nassert 1.0 == IsFloat(exactly=1.0)\nassert 1.001 != IsFloat(exactly=1.0)\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsFloat.allowed_types","title":"<code>allowed_types = float</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>As the name suggests, only floats are allowed.</p>"},{"location":"types/numeric/#dirty_equals.IsPositive","title":"IsPositive","text":"<p>             Bases: <code>IsNumber</code></p> <p>Check that a value is positive (<code>&gt; 0</code>), can be an <code>int</code>, a <code>float</code> or a <code>Decimal</code> (or indeed any value which implements <code>__gt__</code> for <code>0</code>).</p> IsPositive<pre><code>from decimal import Decimal\nfrom dirty_equals import IsPositive\nassert 1.0 == IsPositive\nassert 1 == IsPositive\nassert Decimal('3.14') == IsPositive\nassert 0 != IsPositive\nassert -1 != IsPositive\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsNegative","title":"IsNegative","text":"<p>             Bases: <code>IsNumber</code></p> <p>Check that a value is negative (<code>&lt; 0</code>), can be an <code>int</code>, a <code>float</code> or a <code>Decimal</code> (or indeed any value which implements <code>__lt__</code> for <code>0</code>).</p> IsNegative<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNegative\nassert -1.0 == IsNegative\nassert -1 == IsNegative\nassert Decimal('-3.14') == IsNegative\nassert 0 != IsNegative\nassert 1 != IsNegative\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsNonNegative","title":"IsNonNegative","text":"<p>             Bases: <code>IsNumber</code></p> <p>Check that a value is positive or zero (<code>&gt;= 0</code>), can be an <code>int</code>, a <code>float</code> or a <code>Decimal</code> (or indeed any value which implements <code>__ge__</code> for <code>0</code>).</p> IsNonNegative<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNonNegative\nassert 1.0 == IsNonNegative\nassert 1 == IsNonNegative\nassert Decimal('3.14') == IsNonNegative\nassert 0 == IsNonNegative\nassert -1 != IsNonNegative\nassert Decimal('0') == IsNonNegative\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsNonPositive","title":"IsNonPositive","text":"<p>             Bases: <code>IsNumber</code></p> <p>Check that a value is negative or zero (<code>&lt;=0</code>), can be an <code>int</code>, a <code>float</code> or a <code>Decimal</code> (or indeed any value which implements <code>__le__</code> for <code>0</code>).</p> IsNonPositive<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNonPositive\nassert -1.0 == IsNonPositive\nassert -1 == IsNonPositive\nassert Decimal('-3.14') == IsNonPositive\nassert 0 == IsNonPositive\nassert 1 != IsNonPositive\nassert Decimal('-0') == IsNonPositive\nassert Decimal('0') == IsNonPositive\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsPositiveInt","title":"IsPositiveInt","text":"<p>             Bases: <code>IsInt</code></p> <p>Like <code>IsPositive</code> but only for <code>int</code>s.</p> IsPositiveInt<pre><code>from decimal import Decimal\nfrom dirty_equals import IsPositiveInt\nassert 1 == IsPositiveInt\nassert 1.0 != IsPositiveInt\nassert Decimal('3.14') != IsPositiveInt\nassert 0 != IsPositiveInt\nassert -1 != IsPositiveInt\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsNegativeInt","title":"IsNegativeInt","text":"<p>             Bases: <code>IsInt</code></p> <p>Like <code>IsNegative</code> but only for <code>int</code>s.</p> IsNegativeInt<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNegativeInt\nassert -1 == IsNegativeInt\nassert -1.0 != IsNegativeInt\nassert Decimal('-3.14') != IsNegativeInt\nassert 0 != IsNegativeInt\nassert 1 != IsNegativeInt\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsPositiveFloat","title":"IsPositiveFloat","text":"<p>             Bases: <code>IsFloat</code></p> <p>Like <code>IsPositive</code> but only for <code>float</code>s.</p> IsPositiveFloat<pre><code>from decimal import Decimal\nfrom dirty_equals import IsPositiveFloat\nassert 1.0 == IsPositiveFloat\nassert 1 != IsPositiveFloat\nassert Decimal('3.14') != IsPositiveFloat\nassert 0.0 != IsPositiveFloat\nassert -1.0 != IsPositiveFloat\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsNegativeFloat","title":"IsNegativeFloat","text":"<p>             Bases: <code>IsFloat</code></p> <p>Like <code>IsNegative</code> but only for <code>float</code>s.</p> IsNegativeFloat<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNegativeFloat\nassert -1.0 == IsNegativeFloat\nassert -1 != IsNegativeFloat\nassert Decimal('-3.14') != IsNegativeFloat\nassert 0.0 != IsNegativeFloat\nassert 1.0 != IsNegativeFloat\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsFloatInf","title":"IsFloatInf","text":"<p>             Bases: <code>IsFloat</code></p> <p>Checks that a value is float and infinite (positive or negative).</p> <p>Inherits from <code>IsFloat</code>.</p> IsFloatInf<pre><code>from dirty_equals import IsFloatInf\nassert float('inf') == IsFloatInf\nassert float('-inf') == IsFloatInf\nassert 1.0 != IsFloatInf\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsFloatInfPos","title":"IsFloatInfPos","text":"<p>             Bases: <code>IsFloatInf</code></p> <p>Checks that a value is float and positive infinite.</p> <p>Inherits from <code>IsFloatInf</code>.</p> IsFloatInfPos<pre><code>from dirty_equals import IsFloatInfPos\nassert float('inf') == IsFloatInfPos\nassert -float('-inf') == IsFloatInfPos\nassert -float('inf') != IsFloatInfPos\nassert float('-inf') != IsFloatInfPos\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsFloatInfNeg","title":"IsFloatInfNeg","text":"<p>             Bases: <code>IsFloatInf</code></p> <p>Checks that a value is float and negative infinite.</p> <p>Inherits from <code>IsFloatInf</code>.</p> IsFloatInfNeg<pre><code>from dirty_equals import IsFloatInfNeg\nassert -float('inf') == IsFloatInfNeg\nassert float('-inf') == IsFloatInfNeg\nassert float('inf') != IsFloatInfNeg\nassert -float('-inf') != IsFloatInfNeg\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsFloatNan","title":"IsFloatNan","text":"<p>             Bases: <code>IsFloat</code></p> <p>Checks that a value is float and nan (not a number).</p> <p>Inherits from <code>IsFloat</code>.</p> IsFloatNan<pre><code>from dirty_equals import IsFloatNan\nassert float('nan') == IsFloatNan\nassert 1.0 != IsFloatNan\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsApprox","title":"IsApprox","text":"<pre><code>IsApprox(approx: Num, *, delta: Optional[Num] = None)\n</code></pre> <p>             Bases: <code>IsNumber</code></p> <p>Simplified subclass of <code>IsNumber</code> that only allows approximate comparisons.</p> <p>Parameters:</p> Name Type Description Default <code>approx</code> <code>Num</code> <p>A value to approximately compare to.</p> required <code>delta</code> <code>Optional[Num]</code> <p>The allowable different when comparing to the value to <code>approx</code>, if omitted <code>value / 100</code> is used.</p> <code>None</code> IsApprox<pre><code>from dirty_equals import IsApprox\nassert 1.0 == IsApprox(1)\nassert 123 == IsApprox(120, delta=4)\nassert 201 == IsApprox(200)\nassert 201 != IsApprox(200, delta=0.1)\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsNumber","title":"IsNumber","text":"<p>             Bases: <code>IsNumeric[AnyNumber]</code></p> <p>Base class for all types that can be used with all number types, e.g. numeric but not <code>date</code> or <code>datetime</code>.</p> <p>Inherits from <code>IsNumeric</code> and can therefore be initialised with any of its arguments.</p>"},{"location":"types/numeric/#dirty_equals.IsNumber.allowed_types","title":"allowed_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_types = (int, float, Decimal)\n</code></pre> <p>It allows any of the number types.</p>"},{"location":"types/numeric/#dirty_equals.IsNumeric","title":"IsNumeric","text":"<pre><code>IsNumeric(*, exactly: Optional[N] = None, approx: Optional[N] = None, delta: Optional[N] = None, gt: Optional[N] = None, lt: Optional[N] = None, ge: Optional[N] = None, le: Optional[N] = None)\n</code></pre> <p>             Bases: <code>DirtyEquals[N]</code></p> <p>Base class for all numeric types, <code>IsNumeric</code> implements approximate and inequality comparisons, as well as the type checks.</p> <p>This class can be used directly or via any of its subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>exactly</code> <code>Optional[N]</code> <p>A value to exactly compare to - useful when you want to make sure a value is an <code>int</code> or <code>float</code>, while also checking its value.</p> <code>None</code> <code>approx</code> <code>Optional[N]</code> <p>A value to approximately compare to.</p> <code>None</code> <code>delta</code> <code>Optional[N]</code> <p>The allowable different when comparing to the value to <code>approx</code>, if omitted <code>value / 100</code> is used except for datetimes where 2 seconds is used.</p> <code>None</code> <code>gt</code> <code>Optional[N]</code> <p>Value which the compared value should be greater than.</p> <code>None</code> <code>lt</code> <code>Optional[N]</code> <p>Value which the compared value should be less than.</p> <code>None</code> <code>ge</code> <code>Optional[N]</code> <p>Value which the compared value should be greater than or equal to.</p> <code>None</code> <code>le</code> <code>Optional[N]</code> <p>Value which the compared value should be less than or equal to.</p> <code>None</code> <p>If not values are provided, only the type is checked.</p> <p>If <code>approx</code> is provided as well a <code>gt</code>, <code>lt</code>, <code>ge</code>, or <code>le</code>, a <code>TypeError</code> is raised.</p> <p>Example of direct usage:</p> IsNumeric<pre><code>from datetime import datetime\nfrom dirty_equals import IsNumeric\nassert 1.0 == IsNumeric\nassert 4 == IsNumeric(gt=3)\nd = datetime(2020, 1, 1, 12, 0, 0)\nassert d == IsNumeric(approx=datetime(2020, 1, 1, 12, 0, 1))\n</code></pre>"},{"location":"types/numeric/#dirty_equals.IsNumeric.allowed_types","title":"allowed_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_types: Union[Type[N], Tuple[type, ...]] = (int, float, Decimal, date, datetime)\n</code></pre> <p>It allows any of the types supported in its subclasses.</p>"},{"location":"types/other/","title":"Other Types","text":""},{"location":"types/other/#dirty_equals.FunctionCheck","title":"FunctionCheck","text":"<pre><code>FunctionCheck(func: Callable[[Any], bool])\n</code></pre> <p>             Bases: <code>DirtyEquals[Any]</code></p> <p>Use a function to check if a value \"equals\" whatever you want to check</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Any], bool]</code> <p>callable that takes a value and returns a bool.</p> required FunctionCheck<pre><code>from dirty_equals import FunctionCheck\ndef is_even(x):\nreturn x % 2 == 0\nassert 2 == FunctionCheck(is_even)\nassert 3 != FunctionCheck(is_even)\n</code></pre>"},{"location":"types/other/#dirty_equals.IsInstance","title":"IsInstance","text":"<pre><code>IsInstance(expected_type: ExpectedType, *, only_direct_instance: bool = False)\n</code></pre> <p>             Bases: <code>DirtyEquals[ExpectedType]</code></p> <p>A type which checks that the value is an instance of the expected type.</p> <p>Parameters:</p> Name Type Description Default <code>expected_type</code> <code>ExpectedType</code> <p>The type to check against.</p> required <code>only_direct_instance</code> <code>bool</code> <p>whether instances of subclasses of <code>expected_type</code> should be considered equal.</p> <code>False</code> <p>Note</p> <p><code>IsInstance</code> can be parameterized or initialised with a type - <code>IsInstance[Foo]</code> is exactly equivalent to <code>IsInstance(Foo)</code>.</p> <p>This allows usage to be analogous to type hints.</p> <p>Example: IsInstance<pre><code>from dirty_equals import IsInstance\nclass Foo:\npass\nclass Bar(Foo):\npass\nassert Foo() == IsInstance[Foo]\nassert Foo() == IsInstance(Foo)\nassert Foo != IsInstance[Bar]\nassert Bar() == IsInstance[Foo]\nassert Foo() == IsInstance(Foo, only_direct_instance=True)\nassert Bar() != IsInstance(Foo, only_direct_instance=True)\n</code></pre></p>"},{"location":"types/other/#dirty_equals.IsJson","title":"IsJson","text":"<pre><code>IsJson(expected_value: JsonType = AnyJson, **expected_kwargs: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[JsonType]</code></p> <p>A class that checks if a value is a JSON object, and check the contents of the JSON.</p> <p>Parameters:</p> Name Type Description Default <code>expected_value</code> <code>JsonType</code> <p>Value to compare the JSON to, if omitted, any JSON is accepted.</p> <code>AnyJson</code> <code>**expected_kwargs</code> <code>Any</code> <p>Keyword arguments forming a dict to compare the JSON to, <code>expected_value</code> and <code>expected_kwargs</code> may not be combined.</p> <code>{}</code> <p>As with any <code>dirty_equals</code> type, types can be nested to provide more complex checks.</p> <p>Note</p> <p>Like <code>IsInstance</code>, <code>IsJson</code> can be parameterized or initialised with a value - <code>IsJson[xyz]</code> is exactly equivalent to <code>IsJson(xyz)</code>.</p> <p>This allows usage to be analogous to type hints.</p> IsJson<pre><code>from dirty_equals import IsJson, IsPositiveInt, IsStrictDict\nassert '{\"a\": 1, \"b\": 2}' == IsJson\nassert '{\"a\": 1, \"b\": 2}' == IsJson(a=1, b=2)\nassert '{\"a\": 1}' != IsJson(a=2)\nassert 'invalid json' != IsJson\nassert '{\"a\": 1}' == IsJson(a=IsPositiveInt)\nassert '\"just a quoted string\"' == IsJson('just a quoted string')\nassert '{\"a\": 1, \"b\": 2}' == IsJson[IsStrictDict(a=1, b=2)]\nassert '{\"b\": 2, \"a\": 1}' != IsJson[IsStrictDict(a=1, b=2)]\n</code></pre>"},{"location":"types/other/#dirty_equals.IsUUID","title":"IsUUID","text":"<pre><code>IsUUID(version: Literal[None, 1, 2, 3, 4, 5] = None)\n</code></pre> <p>             Bases: <code>DirtyEquals[UUID]</code></p> <p>A class that checks if a value is a valid UUID, optionally checking UUID version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Literal[None, 1, 2, 3, 4, 5]</code> <p>The version of the UUID to check, if omitted, all versions are accepted.</p> <code>None</code> IsUUID<pre><code>import uuid\nfrom dirty_equals import IsUUID\nassert 'edf9f29e-45c7-431c-99db-28ea44df9785' == IsUUID\nassert 'edf9f29e-45c7-431c-99db-28ea44df9785' == IsUUID(4)\nassert 'edf9f29e45c7431c99db28ea44df9785' == IsUUID(4)\nassert 'edf9f29e-45c7-431c-99db-28ea44df9785' != IsUUID(5)\nassert uuid.uuid4() == IsUUID(4)\n</code></pre>"},{"location":"types/other/#dirty_equals.AnyThing","title":"AnyThing","text":"<pre><code>AnyThing(*repr_args: Any, **repr_kwargs: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[Any]</code></p> <p>A type which matches any value. <code>AnyThing</code> isn't generally very useful on its own, but can be used within other comparisons.</p> AnyThing<pre><code>from dirty_equals import AnyThing, IsList, IsStrictDict\nassert 1 == AnyThing\nassert 'foobar' == AnyThing\nassert [1, 2, 3] == AnyThing\nassert [1, 2, 3] == IsList(AnyThing, 2, 3)\nassert {'a': 1, 'b': 2, 'c': 3} == IsStrictDict(a=1, b=AnyThing, c=3)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*repr_args</code> <code>Any</code> <p>unnamed args to be used in <code>__repr__</code></p> <code>()</code> <code>**repr_kwargs</code> <code>Any</code> <p>named args to be used in <code>__repr__</code></p> <code>{}</code>"},{"location":"types/other/#dirty_equals.IsOneOf","title":"IsOneOf","text":"<pre><code>IsOneOf(expected_value: Any, *more_expected_values: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[Any]</code></p> <p>A type which checks that the value is equal to one of the given values.</p> <p>Can be useful with boolean operators.</p> <p>Parameters:</p> Name Type Description Default <code>expected_value</code> <code>Any</code> <p>Expected value for equals to return true.</p> required <code>*more_expected_values</code> <code>Any</code> <p>More expected values for equals to return true.</p> <code>()</code> IsOneOf<pre><code>from dirty_equals import Contains, IsOneOf\nassert 1 == IsOneOf(1, 2, 3)\nassert 4 != IsOneOf(1, 2, 3)\n# check that a list either contain 1 or is empty\nassert [1, 2, 3] == Contains(1) | IsOneOf([])\nassert [] == Contains(1) | IsOneOf([])\n</code></pre>"},{"location":"types/other/#dirty_equals.IsUrl","title":"IsUrl","text":"<pre><code>IsUrl(any_url: bool = False, any_http_url: bool = False, http_url: bool = False, file_url: bool = False, postgres_dsn: bool = False, ampqp_dsn: bool = False, redis_dsn: bool = False, **expected_attributes: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[Any]</code></p> <p>A class that checks if a value is a valid URL, optionally checking different URL types and attributes with Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>any_url</code> <code>bool</code> <p>any scheme allowed, host required</p> <code>False</code> <code>any_http_url</code> <code>bool</code> <p>scheme http or https, host required</p> <code>False</code> <code>http_url</code> <code>bool</code> <p>scheme http or https, host required, max length 2083</p> <code>False</code> <code>file_url</code> <code>bool</code> <p>scheme file, host not required</p> <code>False</code> <code>postgres_dsn</code> <code>bool</code> <p>user info required</p> <code>False</code> <code>ampqp_dsn</code> <code>bool</code> <p>schema amqp or amqps, user info not required, host not required</p> <code>False</code> <code>redis_dsn</code> <code>bool</code> <p>scheme redis or rediss, user info not required, host not required</p> <code>False</code> <code>**expected_attributes</code> <code>Any</code> <p>Expected values for url attributes</p> <code>{}</code> IsUrl<pre><code>from dirty_equals import IsUrl\nassert 'https://example.com' == IsUrl\nassert 'https://example.com' == IsUrl(host='example.com')\nassert 'https://example.com' == IsUrl(scheme='https')\nassert 'https://example.com' != IsUrl(scheme='http')\nassert 'postgres://user:pass@localhost:5432/app' == IsUrl(postgres_dsn=True)\nassert 'postgres://user:pass@localhost:5432/app' != IsUrl(http_url=True)\n</code></pre>"},{"location":"types/other/#dirty_equals.IsHash","title":"IsHash","text":"<pre><code>IsHash(hash_type: HashTypes)\n</code></pre> <p>             Bases: <code>DirtyEquals[str]</code></p> <p>A class that checks if a value is a valid common hash type, using a simple length and allowed characters regex.</p> <p>Parameters:</p> Name Type Description Default <code>hash_type</code> <code>HashTypes</code> <p>The hash type to check. Must be specified.</p> required IsHash<pre><code>from dirty_equals import IsHash\nassert 'f1e069787ece74531d112559945c6871' == IsHash('md5')\nassert b'f1e069787ece74531d112559945c6871' == IsHash('md5')\nassert 'f1e069787ece74531d112559945c6871' != IsHash('sha-256')\nassert 'F1E069787ECE74531D112559945C6871' == IsHash('md5')\nassert '40bd001563085fc35165329ea1ff5c5ecbdbbeef' == IsHash('sha-1')\nassert 'a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3' == IsHash(\n'sha-256'\n)\n</code></pre>"},{"location":"types/other/#dirty_equals.IsIP","title":"IsIP","text":"<pre><code>IsIP(*, version: Literal[None, 4, 6] = None, netmask: str | None = None)\n</code></pre> <p>             Bases: <code>DirtyEquals[IP]</code></p> <p>A class that checks if a value is a valid IP address, optionally checking IP version, netmask.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Literal[None, 4, 6]</code> <p>The version of the IP to check, if omitted, versions 4 and 6 are both accepted.</p> <code>None</code> <code>netmask</code> <code>str | None</code> <p>The netmask of the IP to check, if omitted, any netmask is accepted. Requires version.</p> <code>None</code> IsIP<pre><code>from ipaddress import IPv4Address, IPv4Network, IPv6Address\nfrom dirty_equals import IsIP\nassert '179.27.154.96' == IsIP\nassert '179.27.154.96' == IsIP(version=4)\nassert '2001:0db8:0a0b:12f0:0000:0000:0000:0001' == IsIP(version=6)\nassert IPv4Address('127.0.0.1') == IsIP\nassert IPv4Network('43.48.0.0/12') == IsIP\nassert IPv6Address('::eeff:ae3f:d473') == IsIP\nassert '54.43.53.219/10' == IsIP(version=4, netmask='255.192.0.0')\nassert '54.43.53.219/10' == IsIP(version=4, netmask=4290772992)\nassert '::ffff:aebf:d473/12' == IsIP(version=6, netmask='fff0::')\nassert 3232235521 == IsIP\n</code></pre>"},{"location":"types/other/#dirty_equals.IsDataclassType","title":"IsDataclassType","text":"<pre><code>IsDataclassType(*repr_args: Any, **repr_kwargs: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[Any]</code></p> <p>Checks that an object is a dataclass type.</p> <p>Inherits from <code>DirtyEquals</code>.</p> IsDataclassType<pre><code>from dataclasses import dataclass\nfrom dirty_equals import IsDataclassType\n@dataclass\nclass Foo:\na: int\nb: int\nfoo = Foo(1, 2)\nassert Foo == IsDataclassType\nassert foo != IsDataclassType\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*repr_args</code> <code>Any</code> <p>unnamed args to be used in <code>__repr__</code></p> <code>()</code> <code>**repr_kwargs</code> <code>Any</code> <p>named args to be used in <code>__repr__</code></p> <code>{}</code>"},{"location":"types/other/#dirty_equals.IsDataclass","title":"IsDataclass","text":"<pre><code>IsDataclass(**fields: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[Any]</code></p> <p>Checks that an object is an instance of a dataclass.</p> <p>Inherits from <code>DirtyEquals</code> and it can be initialised with specific keyword arguments to check exactness of dataclass fields, by comparing the instance <code>__dict__</code>  with <code>IsDict</code>. Moreover it is possible to check for strictness and partialness of the dataclass, by setting the <code>strict</code> and <code>partial</code> attributes using the <code>.settings(strict=..., partial=...)</code> method.</p> <p>Remark that passing no kwargs to <code>IsDataclass</code> initialization means fields are not checked, not that the dataclass is empty, namely <code>IsDataclass()</code> is the same as <code>IsDataclass</code>.</p> IsDataclass<pre><code>from dataclasses import dataclass\nfrom dirty_equals import IsInt, IsDataclass\n@dataclass\nclass Foo:\na: int\nb: int\nc: str\nfoo = Foo(1, 2, 'c')\nassert foo == IsDataclass\nassert foo == IsDataclass(a=IsInt, b=2, c='c')\nassert foo == IsDataclass(b=2, a=1).settings(partial=True)\nassert foo != IsDataclass(a=IsInt, b=2).settings(strict=True)\nassert foo == IsDataclass(a=IsInt, b=2).settings(strict=True, partial=True)\nassert foo != IsDataclass(b=2, a=1).settings(strict=True, partial=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Any</code> <p>key-value pairs of field-value to check for.</p> <code>{}</code>"},{"location":"types/other/#dirty_equals.IsDataclass.settings","title":"settings","text":"<pre><code>settings(*, strict: bool | None = None, partial: bool | None = None) -&gt; IsDataclass\n</code></pre> <p>Allows to customise the behaviour of <code>IsDataclass</code>, technically a new <code>IsDataclass</code> to allow chaining.</p>"},{"location":"types/other/#dirty_equals.IsPartialDataclass","title":"IsPartialDataclass","text":"<pre><code>IsPartialDataclass(**fields: Any)\n</code></pre> <p>             Bases: <code>IsDataclass</code></p> <p>Inherits from <code>IsDataclass</code> with <code>partial=True</code> by default.</p> IsPartialDataclass<pre><code>from dataclasses import dataclass\nfrom dirty_equals import IsInt, IsPartialDataclass\n@dataclass\nclass Foo:\na: int\nb: int\nc: str = 'c'\nfoo = Foo(1, 2, 'c')\nassert foo == IsPartialDataclass\nassert foo == IsPartialDataclass(a=1)\nassert foo == IsPartialDataclass(b=2, a=IsInt)\nassert foo != IsPartialDataclass(b=2, a=IsInt).settings(strict=True)\nassert Foo != IsPartialDataclass\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Any</code> <p>key-value pairs of field-value to check for.</p> <code>{}</code>"},{"location":"types/other/#dirty_equals.IsStrictDataclass","title":"IsStrictDataclass","text":"<pre><code>IsStrictDataclass(**fields: Any)\n</code></pre> <p>             Bases: <code>IsDataclass</code></p> <p>Inherits from <code>IsDataclass</code> with <code>strict=True</code> by default.</p> IsStrictDataclass<pre><code>from dataclasses import dataclass\nfrom dirty_equals import IsInt, IsStrictDataclass\n@dataclass\nclass Foo:\na: int\nb: int\nc: str = 'c'\nfoo = Foo(1, 2, 'c')\nassert foo == IsStrictDataclass\nassert foo == IsStrictDataclass(\na=IsInt,\nb=2,\n).settings(partial=True)\nassert foo != IsStrictDataclass(\na=IsInt,\nb=2,\n).settings(partial=False)\nassert foo != IsStrictDataclass(b=2, a=IsInt, c='c')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Any</code> <p>key-value pairs of field-value to check for.</p> <code>{}</code>"},{"location":"types/other/#dirty_equals.IsEnum","title":"IsEnum","text":"<pre><code>IsEnum(enum_cls: type[Enum] = Enum)\n</code></pre> <p>             Bases: <code>DirtyEquals[Enum]</code></p> <p>Checks if an instance is an Enum.</p> <p>Inherits from <code>DirtyEquals</code>.</p> IsEnum<pre><code>from enum import Enum, auto\nfrom dirty_equals import IsEnum\nclass ExampleEnum(Enum):\na = auto()\nb = auto()\na = ExampleEnum.a\nassert a == IsEnum\nassert a == IsEnum(ExampleEnum)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>enum_cls</code> <code>type[Enum]</code> <p>Enum class to check against.</p> <code>Enum</code>"},{"location":"types/sequence/","title":"Sequence Types","text":""},{"location":"types/sequence/#dirty_equals.IsListOrTuple","title":"IsListOrTuple","text":"<pre><code>IsListOrTuple(*items: Any, positions: Optional[Dict[int, Any]] = None, check_order: bool = True, length: LengthType = None)\n</code></pre> <p>             Bases: <code>DirtyEquals[T]</code></p> <p>Check that some object is a list or tuple and optionally its values match some constraints.</p> <p><code>IsListOrTuple</code> and its subclasses can be initialised in two ways:</p> <p>Parameters:</p> Name Type Description Default <code>*items</code> <code>Any</code> <p>Positional members of an object to check. These must start from the zeroth position, but (depending on the value of <code>length</code>) may not include all values of the list/tuple being checked.</p> <code>()</code> <code>check_order</code> <code>bool</code> <p>Whether to enforce the order of the items.</p> <code>True</code> <code>length</code> <code>Union[int, Tuple[int, Union[int, Any]]]</code> <p>length constraints, int or tuple matching the arguments of <code>HasLen</code>.</p> <code>None</code> <p>or,</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>Dict[int, Any]</code> <p>Instead of <code>*items</code>, a dictionary of positions and values to check and be provided.</p> <code>None</code> <code>length</code> <code>Union[int, Tuple[int, Union[int, Any]]]</code> <p>length constraints, int or tuple matching the arguments of <code>HasLen</code>.</p> <code>None</code> IsListOrTuple<pre><code>from dirty_equals import AnyThing, IsListOrTuple\nassert [1, 2, 3] == IsListOrTuple(1, 2, 3)\nassert (1, 3, 2) == IsListOrTuple(1, 2, 3, check_order=False)\nassert [{'a': 1}, {'a': 2}] == (\nIsListOrTuple({'a': 2}, {'a': 1}, check_order=False)  # (1)!\n)\nassert [1, 2, 3, 3] != IsListOrTuple(1, 2, 3, check_order=False)  # (2)!\nassert [1, 2, 3, 4, 5] == IsListOrTuple(1, 2, 3, length=...)  # (3)!\nassert [1, 2, 3, 4, 5] != IsListOrTuple(1, 2, 3, length=(8, 10))  # (4)!\nassert ['a', 'b', 'c', 'd'] == (IsListOrTuple(positions={2: 'c', 3: 'd'}))  # (5)!\nassert ['a', 'b', 'c', 'd'] == (\nIsListOrTuple(positions={2: 'c', 3: 'd'}, length=4)  # (6)!\n)\nassert [1, 2, 3, 4] == IsListOrTuple(3, check_order=False, length=(0, ...))  # (7)!\nassert [1, 2, 3] == IsListOrTuple(AnyThing, AnyThing, 3)  # (8)!\n</code></pre> <ol> <li>Unlike using sets for comparison, we can do order-insensitive comparisons on objects that are not hashable.</li> <li>And we won't get caught out by duplicate values</li> <li>Here we're just checking the first 3 items, the compared list or tuple can be of any length</li> <li>Compared list is not long enough</li> <li>Compare using <code>positions</code>, here no length if enforced</li> <li>Compare using <code>positions</code> but with a length constraint</li> <li>Here we're just confirming that the value <code>3</code> is in the list</li> <li>If you don't care about the first few values of a list or tuple,     you can use <code>AnyThing</code> in your arguments.</li> </ol>"},{"location":"types/sequence/#dirty_equals.IsList","title":"IsList","text":"<pre><code>IsList(*items: Any, positions: Optional[Dict[int, Any]] = None, check_order: bool = True, length: LengthType = None)\n</code></pre> <p>             Bases: <code>IsListOrTuple[List[Any]]</code></p> <p>All the same functionality as <code>IsListOrTuple</code>, but the compared value must be a list.</p> IsList<pre><code>from dirty_equals import IsList\nassert [1, 2, 3] == IsList(1, 2, 3)\nassert [1, 2, 3] == IsList(positions={2: 3})\nassert [1, 2, 3] == IsList(1, 2, 3, check_order=False)\nassert [1, 2, 3, 4] == IsList(1, 2, 3, length=4)\nassert [1, 2, 3, 4] == IsList(1, 2, 3, length=(4, 5))\nassert [1, 2, 3, 4] == IsList(1, 2, 3, length=...)\nassert (1, 2, 3) != IsList(1, 2, 3)\n</code></pre> <p><code>IsListOrTuple</code> and its subclasses can be initialised in two ways:</p> <p>Parameters:</p> Name Type Description Default <code>*items</code> <code>Any</code> <p>Positional members of an object to check. These must start from the zeroth position, but (depending on the value of <code>length</code>) may not include all values of the list/tuple being checked.</p> <code>()</code> <code>check_order</code> <code>bool</code> <p>Whether to enforce the order of the items.</p> <code>True</code> <code>length</code> <code>Union[int, Tuple[int, Union[int, Any]]]</code> <p>length constraints, int or tuple matching the arguments of <code>HasLen</code>.</p> <code>None</code> <p>or,</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>Dict[int, Any]</code> <p>Instead of <code>*items</code>, a dictionary of positions and values to check and be provided.</p> <code>None</code> <code>length</code> <code>Union[int, Tuple[int, Union[int, Any]]]</code> <p>length constraints, int or tuple matching the arguments of <code>HasLen</code>.</p> <code>None</code> IsListOrTuple<pre><code>from dirty_equals import AnyThing, IsListOrTuple\nassert [1, 2, 3] == IsListOrTuple(1, 2, 3)\nassert (1, 3, 2) == IsListOrTuple(1, 2, 3, check_order=False)\nassert [{'a': 1}, {'a': 2}] == (\nIsListOrTuple({'a': 2}, {'a': 1}, check_order=False)  # (1)!\n)\nassert [1, 2, 3, 3] != IsListOrTuple(1, 2, 3, check_order=False)  # (2)!\nassert [1, 2, 3, 4, 5] == IsListOrTuple(1, 2, 3, length=...)  # (3)!\nassert [1, 2, 3, 4, 5] != IsListOrTuple(1, 2, 3, length=(8, 10))  # (4)!\nassert ['a', 'b', 'c', 'd'] == (IsListOrTuple(positions={2: 'c', 3: 'd'}))  # (5)!\nassert ['a', 'b', 'c', 'd'] == (\nIsListOrTuple(positions={2: 'c', 3: 'd'}, length=4)  # (6)!\n)\nassert [1, 2, 3, 4] == IsListOrTuple(3, check_order=False, length=(0, ...))  # (7)!\nassert [1, 2, 3] == IsListOrTuple(AnyThing, AnyThing, 3)  # (8)!\n</code></pre> <ol> <li>Unlike using sets for comparison, we can do order-insensitive comparisons on objects that are not hashable.</li> <li>And we won't get caught out by duplicate values</li> <li>Here we're just checking the first 3 items, the compared list or tuple can be of any length</li> <li>Compared list is not long enough</li> <li>Compare using <code>positions</code>, here no length if enforced</li> <li>Compare using <code>positions</code> but with a length constraint</li> <li>Here we're just confirming that the value <code>3</code> is in the list</li> <li>If you don't care about the first few values of a list or tuple,     you can use <code>AnyThing</code> in your arguments.</li> </ol>"},{"location":"types/sequence/#dirty_equals.IsTuple","title":"IsTuple","text":"<pre><code>IsTuple(*items: Any, positions: Optional[Dict[int, Any]] = None, check_order: bool = True, length: LengthType = None)\n</code></pre> <p>             Bases: <code>IsListOrTuple[Tuple[Any, ...]]</code></p> <p>All the same functionality as <code>IsListOrTuple</code>, but the compared value must be a tuple.</p> IsTuple<pre><code>from dirty_equals import IsTuple\nassert (1, 2, 3) == IsTuple(1, 2, 3)\nassert (1, 2, 3) == IsTuple(positions={2: 3})\nassert (1, 2, 3) == IsTuple(1, 2, 3, check_order=False)\nassert (1, 2, 3, 4) == IsTuple(1, 2, 3, length=4)\nassert (1, 2, 3, 4) == IsTuple(1, 2, 3, length=(4, 5))\nassert (1, 2, 3, 4) == IsTuple(1, 2, 3, length=...)\nassert [1, 2, 3] != IsTuple(1, 2, 3)\n</code></pre> <p><code>IsListOrTuple</code> and its subclasses can be initialised in two ways:</p> <p>Parameters:</p> Name Type Description Default <code>*items</code> <code>Any</code> <p>Positional members of an object to check. These must start from the zeroth position, but (depending on the value of <code>length</code>) may not include all values of the list/tuple being checked.</p> <code>()</code> <code>check_order</code> <code>bool</code> <p>Whether to enforce the order of the items.</p> <code>True</code> <code>length</code> <code>Union[int, Tuple[int, Union[int, Any]]]</code> <p>length constraints, int or tuple matching the arguments of <code>HasLen</code>.</p> <code>None</code> <p>or,</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>Dict[int, Any]</code> <p>Instead of <code>*items</code>, a dictionary of positions and values to check and be provided.</p> <code>None</code> <code>length</code> <code>Union[int, Tuple[int, Union[int, Any]]]</code> <p>length constraints, int or tuple matching the arguments of <code>HasLen</code>.</p> <code>None</code> IsListOrTuple<pre><code>from dirty_equals import AnyThing, IsListOrTuple\nassert [1, 2, 3] == IsListOrTuple(1, 2, 3)\nassert (1, 3, 2) == IsListOrTuple(1, 2, 3, check_order=False)\nassert [{'a': 1}, {'a': 2}] == (\nIsListOrTuple({'a': 2}, {'a': 1}, check_order=False)  # (1)!\n)\nassert [1, 2, 3, 3] != IsListOrTuple(1, 2, 3, check_order=False)  # (2)!\nassert [1, 2, 3, 4, 5] == IsListOrTuple(1, 2, 3, length=...)  # (3)!\nassert [1, 2, 3, 4, 5] != IsListOrTuple(1, 2, 3, length=(8, 10))  # (4)!\nassert ['a', 'b', 'c', 'd'] == (IsListOrTuple(positions={2: 'c', 3: 'd'}))  # (5)!\nassert ['a', 'b', 'c', 'd'] == (\nIsListOrTuple(positions={2: 'c', 3: 'd'}, length=4)  # (6)!\n)\nassert [1, 2, 3, 4] == IsListOrTuple(3, check_order=False, length=(0, ...))  # (7)!\nassert [1, 2, 3] == IsListOrTuple(AnyThing, AnyThing, 3)  # (8)!\n</code></pre> <ol> <li>Unlike using sets for comparison, we can do order-insensitive comparisons on objects that are not hashable.</li> <li>And we won't get caught out by duplicate values</li> <li>Here we're just checking the first 3 items, the compared list or tuple can be of any length</li> <li>Compared list is not long enough</li> <li>Compare using <code>positions</code>, here no length if enforced</li> <li>Compare using <code>positions</code> but with a length constraint</li> <li>Here we're just confirming that the value <code>3</code> is in the list</li> <li>If you don't care about the first few values of a list or tuple,     you can use <code>AnyThing</code> in your arguments.</li> </ol>"},{"location":"types/sequence/#dirty_equals.HasLen","title":"HasLen","text":"<pre><code>HasLen(min_length: int, max_length: Union[None, int, Any] = None)\n</code></pre> <p>             Bases: <code>DirtyEquals[Sized]</code></p> <p>Check that some has a given length, or length in a given range.</p> <p>Parameters:</p> Name Type Description Default <code>min_length</code> <code>int</code> <p>Expected length if <code>max_length</code> is not given, else minimum length.</p> required <code>max_length</code> <code>Union[None, int, Any]</code> <p>Expected maximum length, use an ellipsis <code>...</code> to indicate that there's no maximum.</p> <code>None</code> HasLen<pre><code>from dirty_equals import HasLen\nassert [1, 2, 3] == HasLen(3)  # (1)!\nassert '123' == HasLen(3, ...)  # (2)!\nassert (1, 2, 3) == HasLen(3, 5)  # (3)!\nassert (1, 2, 3) == HasLen(0, ...)  # (4)!\n</code></pre> <ol> <li>Length must be 3.</li> <li>Length must be 3 or higher.</li> <li>Length must be between 3 and 5 inclusive.</li> <li>Length is required but can take any value.</li> </ol>"},{"location":"types/sequence/#dirty_equals.Contains","title":"Contains","text":"<pre><code>Contains(contained_value: Any, *more_contained_values: Any)\n</code></pre> <p>             Bases: <code>DirtyEquals[Container[Any]]</code></p> <p>Check that an object contains one or more values.</p> <p>Parameters:</p> Name Type Description Default <code>contained_value</code> <code>Any</code> <p>value that must be contained in the compared object.</p> required <code>*more_contained_values</code> <code>Any</code> <p>more values that must be contained in the compared object.</p> <code>()</code> Contains<pre><code>from dirty_equals import Contains\nassert [1, 2, 3] == Contains(1)\nassert [1, 2, 3] == Contains(1, 2)\nassert (1, 2, 3) == Contains(1)\nassert 'abc' == Contains('b')\nassert {'a': 1, 'b': 2} == Contains('a')\nassert [1, 2, 3] != Contains(10)\n</code></pre>"},{"location":"types/string/","title":"String Types","text":""},{"location":"types/string/#dirty_equals.IsAnyStr","title":"IsAnyStr","text":"<pre><code>IsAnyStr(*, min_length: Optional[int] = None, max_length: Optional[int] = None, case: Literal['upper', 'lower', None] = None, regex: Union[None, T, Pattern[T]] = None, regex_flags: int = 0)\n</code></pre> <p>             Bases: <code>DirtyEquals[T]</code></p> <p>Comparison of <code>str</code> or <code>bytes</code> objects.</p> <p>This class allow comparison with both <code>str</code> and <code>bytes</code> but is subclassed by <code>IsStr</code> and <code>IsBytes</code> which restrict comparison to <code>str</code> or <code>bytes</code> respectively.</p> <p>Parameters:</p> Name Type Description Default <code>min_length</code> <code>Optional[int]</code> <p>minimum length of the string/bytes</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>maximum length of the string/bytes</p> <code>None</code> <code>case</code> <code>Literal['upper', 'lower', None]</code> <p>check case of the string/bytes</p> <code>None</code> <code>regex</code> <code>Union[None, T, Pattern[T]]</code> <p>regular expression to match the string/bytes with, <code>re.fullmatch</code> is used. This can be a compiled regex, or a string or bytes.</p> <code>None</code> <code>regex_flags</code> <code>int</code> <p>optional flags for the regular expression</p> <code>0</code> <p>Examples: IsAnyStr<pre><code>from dirty_equals import IsAnyStr\nassert 'foobar' == IsAnyStr()\nassert b'foobar' == IsAnyStr()\nassert 123 != IsAnyStr()\nassert 'foobar' == IsAnyStr(regex='foo...')\nassert 'foobar' == IsAnyStr(regex=b'foo...')  # (1)!\nassert 'foobar' == IsAnyStr(min_length=6)\nassert 'foobar' != IsAnyStr(min_length=8)\nassert 'foobar' == IsAnyStr(case='lower')\nassert 'Foobar' != IsAnyStr(case='lower')\n</code></pre></p> <ol> <li><code>regex</code> can be either a string or bytes, <code>IsAnyStr</code> will take care of conversion so checks work.</li> </ol>"},{"location":"types/string/#dirty_equals.IsStr","title":"IsStr","text":"<pre><code>IsStr(*, min_length: Optional[int] = None, max_length: Optional[int] = None, case: Literal['upper', 'lower', None] = None, regex: Union[None, T, Pattern[T]] = None, regex_flags: int = 0)\n</code></pre> <p>             Bases: <code>IsAnyStr[str]</code></p> <p>Checks if the value is a string, and optionally meets some constraints.</p> <p><code>IsStr</code> is a subclass of <code>IsAnyStr</code> and therefore allows all the same arguments.</p> <p>Examples: IsStr<pre><code>from dirty_equals import IsStr\nassert 'foobar' == IsStr()\nassert b'foobar' != IsStr()\nassert 'foobar' == IsStr(regex='foo...')\nassert 'FOOBAR' == IsStr(min_length=5, max_length=10, case='upper')\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>min_length</code> <code>Optional[int]</code> <p>minimum length of the string/bytes</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>maximum length of the string/bytes</p> <code>None</code> <code>case</code> <code>Literal['upper', 'lower', None]</code> <p>check case of the string/bytes</p> <code>None</code> <code>regex</code> <code>Union[None, T, Pattern[T]]</code> <p>regular expression to match the string/bytes with, <code>re.fullmatch</code> is used. This can be a compiled regex, or a string or bytes.</p> <code>None</code> <code>regex_flags</code> <code>int</code> <p>optional flags for the regular expression</p> <code>0</code> <p>Examples: IsAnyStr<pre><code>from dirty_equals import IsAnyStr\nassert 'foobar' == IsAnyStr()\nassert b'foobar' == IsAnyStr()\nassert 123 != IsAnyStr()\nassert 'foobar' == IsAnyStr(regex='foo...')\nassert 'foobar' == IsAnyStr(regex=b'foo...')  # (1)!\nassert 'foobar' == IsAnyStr(min_length=6)\nassert 'foobar' != IsAnyStr(min_length=8)\nassert 'foobar' == IsAnyStr(case='lower')\nassert 'Foobar' != IsAnyStr(case='lower')\n</code></pre></p> <ol> <li><code>regex</code> can be either a string or bytes, <code>IsAnyStr</code> will take care of conversion so checks work.</li> </ol>"},{"location":"types/string/#dirty_equals.IsBytes","title":"IsBytes","text":"<pre><code>IsBytes(*, min_length: Optional[int] = None, max_length: Optional[int] = None, case: Literal['upper', 'lower', None] = None, regex: Union[None, T, Pattern[T]] = None, regex_flags: int = 0)\n</code></pre> <p>             Bases: <code>IsAnyStr[bytes]</code></p> <p>Checks if the value is a bytes object, and optionally meets some constraints.</p> <p><code>IsBytes</code> is a subclass of <code>IsAnyStr</code> and therefore allows all the same arguments.</p> <p>Examples: IsBytes<pre><code>from dirty_equals import IsBytes\nassert b'foobar' == IsBytes()\nassert 'foobar' != IsBytes()\nassert b'foobar' == IsBytes(regex=b'foo...')\nassert b'FOOBAR' == IsBytes(min_length=5, max_length=10, case='upper')\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>min_length</code> <code>Optional[int]</code> <p>minimum length of the string/bytes</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>maximum length of the string/bytes</p> <code>None</code> <code>case</code> <code>Literal['upper', 'lower', None]</code> <p>check case of the string/bytes</p> <code>None</code> <code>regex</code> <code>Union[None, T, Pattern[T]]</code> <p>regular expression to match the string/bytes with, <code>re.fullmatch</code> is used. This can be a compiled regex, or a string or bytes.</p> <code>None</code> <code>regex_flags</code> <code>int</code> <p>optional flags for the regular expression</p> <code>0</code> <p>Examples: IsAnyStr<pre><code>from dirty_equals import IsAnyStr\nassert 'foobar' == IsAnyStr()\nassert b'foobar' == IsAnyStr()\nassert 123 != IsAnyStr()\nassert 'foobar' == IsAnyStr(regex='foo...')\nassert 'foobar' == IsAnyStr(regex=b'foo...')  # (1)!\nassert 'foobar' == IsAnyStr(min_length=6)\nassert 'foobar' != IsAnyStr(min_length=8)\nassert 'foobar' == IsAnyStr(case='lower')\nassert 'Foobar' != IsAnyStr(case='lower')\n</code></pre></p> <ol> <li><code>regex</code> can be either a string or bytes, <code>IsAnyStr</code> will take care of conversion so checks work.</li> </ol>"}]}